# -*- coding: utf-8 -*-
"""Py_Puzzle.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AvcPJ-MpObET9Hn6Trv52RjfSd_HTDGG
"""

# Python Programming Puzzles
# Instructions: Solve each puzzle and commit your solutions to GitHub

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

print("=" * 60)
print("PYTHON PROGRAMMING PUZZLES")
print("=" * 60)
print("Instructions:")
print("1. Solve each puzzle in order")
print("2. Test your solutions with the provided sample data")
print("3. Commit your solutions to your GitHub repository (later)")
print("4. Include proper documentation and comments")
print("5. Add visualizations where appropriate")
print("=" * 60)

# =============================================================================
# PUZZLE 1: SUPPLY AND DEMAND EQUILIBRIUM
# Difficulty: Beginner
# =============================================================================

print("\n🧩 PUZZLE 1: Find Market Equilibrium")
print("─" * 35)
print("Given supply and demand functions, find the equilibrium price and quantity")
print("Supply: Qs = -10 + 2*P")
print("Demand: Qd = 100 - 3*P")

def find_equilibrium(supply_intercept, supply_slope, demand_intercept, demand_slope):
    """
    Find market equilibrium point where supply equals demand.

    Supply: Qs = supply_intercept + supply_slope * P
    Demand: Qd = demand_intercept + demand_slope * P

    Requirements:
    1. Calculate equilibrium price
    2. Calculate equilibrium quantity
    3. Return both as a dictionary
    4. Handle the case where lines are parallel (no equilibrium)

    Args:
        supply_intercept (float): Supply curve intercept
        supply_slope (float): Supply curve slope
        demand_intercept (float): Demand curve intercept
        demand_slope (float): Demand curve slope (should be negative)

    Returns:
        dict: {'price': float, 'quantity': float} or None if no equilibrium
    """
    # YOUR CODE HERE
    pass

def plot_supply_demand(supply_intercept, supply_slope, demand_intercept, demand_slope, equilibrium):
    """
    Plot supply and demand curves with equilibrium point marked.

    Requirements:
    1. Create price range from 0 to reasonable maximum
    2. Calculate quantity for each curve at each price
    3. Plot both curves on same graph
    4. Mark equilibrium point with a red dot
    5. Add labels, legend, and title
    """
    # YOUR CODE HERE
    pass

print("Test case: Supply: Qs = -10 + 2*P, Demand: Qd = 100 - 3*P")
print("Expected equilibrium: P = 22, Q = 34")

# =============================================================================
# PUZZLE 2: ELASTICITY CALCULATOR
# Difficulty: Beginner-Intermediate
# =============================================================================

print("\n🧩 PUZZLE 2: Calculate Price Elasticity of Demand")
print("─" * 48)
print("Calculate price elasticity using the midpoint method")

# Sample price and quantity data
price_quantity_data = pd.DataFrame({
    'price': [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
    'quantity_demanded': [5, 8, 12, 17, 23, 30, 38, 47, 57, 68]
})

def calculate_elasticity(price1, quantity1, price2, quantity2):
    """
    Calculate price elasticity of demand using midpoint method.

    Formula: Elasticity = (% change in quantity) / (% change in price)
    Midpoint method: ((Q2-Q1)/((Q2+Q1)/2)) / ((P2-P1)/((P2+P1)/2))

    Requirements:
    1. Use midpoint method for accurate calculation
    2. Handle division by zero
    3. Return the elasticity value
    4. Classify as elastic, inelastic, or unit elastic

    Args:
        price1, price2 (float): Initial and final prices
        quantity1, quantity2 (float): Initial and final quantities

    Returns:
        dict: {'elasticity': float, 'classification': str}
    """
    # YOUR CODE HERE
    pass

def analyze_demand_curve(df):
    """
    Analyze entire demand curve and calculate elasticity at each point.

    Requirements:
    1. Calculate elasticity between each consecutive pair of points
    2. Classify each elasticity
    3. Create a summary DataFrame
    4. Plot demand curve with elasticity regions marked

    Args:
        df (pd.DataFrame): DataFrame with 'price' and 'quantity_demanded' columns

    Returns:
        pd.DataFrame: Summary with price ranges and elasticities
    """
    # YOUR CODE HERE
    pass

print("Test with the provided price_quantity_data")
print("Expected: Elasticity should vary along the demand curve")

# =============================================================================
# PUZZLE 3: CONSUMER AND PRODUCER SURPLUS
# Difficulty: Intermediate
# =============================================================================

print("\n🧩 PUZZLE 3: Calculate Economic Surplus")
print("─" * 38)
print("Calculate consumer surplus, producer surplus, and deadweight loss")

def calculate_surplus(demand_intercept, demand_slope, supply_intercept, supply_slope,
                     price=None, quantity=None):
    """
    Calculate consumer and producer surplus at market equilibrium or given price.

    Requirements:
    1. Find equilibrium if price/quantity not provided
    2. Calculate consumer surplus (area under demand curve above price)
    3. Calculate producer surplus (area above supply curve below price)
    4. Calculate total surplus
    5. Handle linear demand and supply curves

    Args:
        demand_intercept, demand_slope: Demand curve parameters
        supply_intercept, supply_slope: Supply curve parameters
        price, quantity: Optional specific price/quantity (default: equilibrium)

    Returns:
        dict: {'consumer_surplus': float, 'producer_surplus': float,
               'total_surplus': float, 'price': float, 'quantity': float}
    """
    # YOUR CODE HERE
    pass

def deadweight_loss_analysis(demand_intercept, demand_slope, supply_intercept, supply_slope,
                           regulated_price):
    """
    Calculate deadweight loss when price is regulated (price ceiling/floor).

    Requirements:
    1. Calculate equilibrium surplus
    2. Calculate surplus at regulated price
    3. Calculate deadweight loss
    4. Determine if regulation is price ceiling or floor
    5. Calculate shortage or surplus quantity

    Args:
        demand_intercept, demand_slope: Demand curve parameters
        supply_intercept, supply_slope: Supply curve parameters
        regulated_price: Government-imposed price

    Returns:
        dict: Analysis results including deadweight loss
    """
    # YOUR CODE HERE
    pass

print("Test case: Same supply/demand from Puzzle 1")
print("Try regulated price of 15 (price ceiling)")

# =============================================================================
# PUZZLE 4: BUDGET CONSTRAINT AND UTILITY MAXIMIZATION
# Difficulty: Intermediate
# =============================================================================

print("\n🧩 PUZZLE 4: Consumer Choice Theory")
print("─" * 37)
print("Find optimal consumption bundle given budget constraint and preferences")

def budget_constraint(income, price_x, price_y):
    """
    Generate budget constraint line: income = price_x * x + price_y * y

    Requirements:
    1. Create array of possible x values
    2. Calculate corresponding y values
    3. Handle boundary conditions
    4. Return feasible consumption combinations

    Args:
        income (float): Consumer's income
        price_x, price_y (float): Prices of goods X and Y

    Returns:
        dict: {'x_values': array, 'y_values': array, 'max_x': float, 'max_y': float}
    """
    # YOUR CODE HERE
    pass

def cobb_douglas_utility(x, y, alpha=0.5):
    """
    Calculate utility using Cobb-Douglas function: U = x^alpha * y^(1-alpha)

    Requirements:
    1. Handle arrays of x and y values
    2. Default alpha = 0.5 (equal preference)
    3. Handle edge cases (zero consumption)

    Args:
        x, y: Quantities of goods X and Y
        alpha: Preference parameter (0 < alpha < 1)

    Returns:
        Utility value(s)
    """
    # YOUR CODE HERE
    pass

def find_optimal_consumption(income, price_x, price_y, alpha=0.5):
    """
    Find utility-maximizing consumption bundle.

    For Cobb-Douglas utility with budget constraint:
    Optimal x* = (alpha * income) / price_x
    Optimal y* = ((1-alpha) * income) / price_y

    Requirements:
    1. Calculate optimal quantities analytically
    2. Verify budget constraint is satisfied
    3. Calculate maximum utility
    4. Plot indifference curves and budget line

    Args:
        income: Consumer's income
        price_x, price_y: Prices of goods
        alpha: Preference parameter

    Returns:
        dict: {'x_optimal': float, 'y_optimal': float, 'max_utility': float}
    """
    # YOUR CODE HERE
    pass

print("Test case: Income = 100, Price_x = 5, Price_y = 2, alpha = 0.6")
print("Expected: x* = 12, y* = 20, U* ≈ 16.87")

# =============================================================================
# PUZZLE 5: GDP CALCULATION AND GROWTH RATES
# Difficulty: Beginner-Intermediate
# =============================================================================

print("\n🧩 PUZZLE 5: GDP Analysis")
print("─" * 25)
print("Calculate GDP using different methods and analyze growth rates")

# Sample economic data
economic_data = {
    'consumption': [800, 820, 850, 880, 900],
    'investment': [200, 180, 220, 240, 260],
    'government_spending': [300, 310, 305, 320, 330],
    'exports': [150, 160, 170, 180, 185],
    'imports': [120, 130, 145, 150, 155],
    'year': [2019, 2020, 2021, 2022, 2023]
}

gdp_data = pd.DataFrame(economic_data)

def calculate_gdp_expenditure(consumption, investment, government, exports, imports):
    """
    Calculate GDP using expenditure approach: GDP = C + I + G + (X - M)

    Requirements:
    1. Handle both single values and arrays
    2. Calculate net exports correctly
    3. Return GDP value(s)

    Args:
        consumption, investment, government, exports, imports: Economic components

    Returns:
        GDP value or array of GDP values
    """
    # YOUR CODE HERE
    pass

def calculate_growth_rates(gdp_series):
    """
    Calculate year-over-year GDP growth rates.

    Requirements:
    1. Calculate percentage growth: ((GDP_t - GDP_{t-1}) / GDP_{t-1}) * 100
    2. Handle first year (no previous year)
    3. Calculate average growth rate
    4. Identify recession periods (negative growth)

    Args:
        gdp_series: Array or Series of GDP values

    Returns:
        dict: {'growth_rates': array, 'average_growth': float, 'recession_years': list}
    """
    # YOUR CODE HERE
    pass

def gdp_analysis_dashboard(df):
    """
    Create comprehensive GDP analysis with visualizations.

    Requirements:
    1. Calculate GDP for each year
    2. Calculate growth rates
    3. Create multiple plots: GDP level, growth rates, components
    4. Identify key economic trends
    5. Generate summary statistics

    Args:
        df: DataFrame with economic components and years

    Returns:
        dict: Complete analysis results
    """
    # YOUR CODE HERE
    pass

print("Test with provided economic_data")
print("Expected: GDP should show overall upward trend with growth rate variations")

# =============================================================================
# PUZZLE 6: INFLATION AND REAL VS NOMINAL VALUES
# Difficulty: Beginner-Intermediate
# =============================================================================

print("\n🧩 PUZZLE 6: Price Index and Inflation Analysis")
print("─" * 47)
print("Calculate CPI, inflation rates, and convert nominal to real values")

# Sample price data for market basket
price_data = pd.DataFrame({
    'year': [2020, 2021, 2022, 2023],
    'bread_price': [2.50, 2.65, 2.80, 3.00],
    'milk_price': [3.20, 3.35, 3.60, 3.75],
    'gas_price': [2.85, 3.10, 4.20, 3.80],
    'bread_quantity': [100, 100, 100, 100],  # Base year quantities
    'milk_quantity': [50, 50, 50, 50],
    'gas_quantity': [200, 200, 200, 200]
})

def calculate_cpi(df, base_year=2020):
    """
    Calculate Consumer Price Index using Laspeyres method.

    CPI = (Cost of basket in current year / Cost of basket in base year) * 100

    Requirements:
    1. Calculate cost of market basket for each year
    2. Use base year quantities throughout
    3. Set base year CPI = 100
    4. Handle multiple goods

    Args:
        df: DataFrame with prices and quantities
        base_year: Base year for index (default 2020)

    Returns:
        pd.Series: CPI values for each year
    """
    # YOUR CODE HERE
    pass

def calculate_inflation_rate(cpi_series):
    """
    Calculate annual inflation rates from CPI data.

    Inflation rate = ((CPI_t - CPI_{t-1}) / CPI_{t-1}) * 100

    Requirements:
    1. Calculate year-over-year inflation
    2. Handle first year appropriately
    3. Identify periods of deflation
    4. Calculate average inflation rate

    Args:
        cpi_series: Series of CPI values

    Returns:
        dict: {'inflation_rates': Series, 'average_inflation': float}
    """
    # YOUR CODE HERE
    pass

def nominal_to_real(nominal_values, cpi_values, base_year_cpi=100):
    """
    Convert nominal values to real values using CPI.

    Real value = (Nominal value / CPI) * base_year_cpi

    Requirements:
    1. Handle arrays of values
    2. Use appropriate CPI deflator
    3. Maintain base year reference

    Args:
        nominal_values: Array of nominal values
        cpi_values: Corresponding CPI values
        base_year_cpi: CPI value for base year (default 100)

    Returns:
        Array of real values
    """
    # YOUR CODE HERE
    pass

print("Test with provided price_data")
print("Expected: CPI should generally increase, showing inflation")

# =============================================================================
# TESTING SECTION
# =============================================================================

print("\n" + "=" * 60)
print("TESTING YOUR SOLUTIONS")
print("=" * 60)
print("Run your functions with the test cases provided above.")
print("Make sure to:")
print("1. Handle edge cases appropriately")
print("2. Include proper error checking")
print("3. Add clear documentation")
print("4. Create meaningful visualizations")
print("5. Test with different parameter values")
print("\nGood luck! 🚀")

# Sample test runner (students can expand this)
def run_tests():
    """
    Run basic tests for all puzzle solutions.
    Students should expand this with their own test cases.
    """
    print("\n🧪 Running basic tests...")

    # Test Puzzle 1
    try:
        eq = find_equilibrium(-10, 2, 100, -3)
        print(f"✅ Puzzle 1 - Equilibrium: {eq}")
    except:
        print("❌ Puzzle 1 - Error in equilibrium calculation")

    # Test Puzzle 2
    try:
        elast = calculate_elasticity(10, 5, 9, 8)
        print(f"✅ Puzzle 2 - Elasticity: {elast}")
    except:
        print("❌ Puzzle 2 - Error in elasticity calculation")

    # Add more tests for other puzzles...

if __name__ == "__main__":
    run_tests()

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

print("=" * 60)
print("PYTHON PROGRAMMING PUZZLES")
print("=" * 60)
print("Instructions:")
print("1. Solve each puzzle in order")
print("2. Test your solutions with the provided sample data")
# 3. Commit your solutions to your GitHub repository (later)") # Fixed: Commented out the line
print("4. Include proper documentation and comments")
print("5. Add visualizations where appropriate")
print("=" * 60)

# =============================================================================
# PUZZLE 1: SUPPLY AND DEMAND EQUILIBRIUM
# =============================================================================

print("\n🧩 PUZZLE 1: Find Market Equilibrium")
print("─" * 35)
print("Given supply and demand functions, find the equilibrium price and quantity")
print("Supply: Qs = -10 + 2*P")
print("Demand: Qd = 100 - 3*P")

def find_equilibrium(supply_intercept, supply_slope, demand_intercept, demand_slope):
    """
    Find market equilibrium where supply equals demand:
    supply_intercept + supply_slope * P = demand_intercept + demand_slope * P

    Return dict with 'price' and 'quantity' or None if no equilibrium exists (parallel lines).
    """
    # Check for parallel lines (no equilibrium)
    denominator = supply_slope - demand_slope
    if denominator == 0:
        return None

    # Calculate equilibrium price
    price_eq = (demand_intercept - supply_intercept) / denominator

    # Calculate equilibrium quantity using either supply or demand
    quantity_eq = supply_intercept + supply_slope * price_eq

    return {'price': price_eq, 'quantity': quantity_eq}

def plot_supply_demand(supply_intercept, supply_slope, demand_intercept, demand_slope, equilibrium):
    """
    Plot supply and demand curves and mark equilibrium point.
    """
    # Determine a price range for plotting - from 0 to slightly above equilibrium price * 1.5
    max_price = max(30, equilibrium['price'] * 1.5 if equilibrium else 30)
    prices = np.linspace(0, max_price, 200)

    # Calculate quantities for supply and demand
    supply_qty = supply_intercept + supply_slope * prices
    demand_qty = demand_intercept + demand_slope * prices

    plt.figure(figsize=(8,6))
    plt.plot(prices, supply_qty, label="Supply Curve (Qs)", color="blue")
    plt.plot(prices, demand_qty, label="Demand Curve (Qd)", color="green")

    if equilibrium:
        plt.scatter(equilibrium['price'], equilibrium['quantity'], color='red', s=80, zorder=5, label="Equilibrium")
        plt.annotate(f"P={equilibrium['price']:.2f}\nQ={equilibrium['quantity']:.2f}",
                     (equilibrium['price'], equilibrium['quantity']),
                     textcoords="offset points", xytext=(10,-30), ha='center',
                     arrowprops=dict(arrowstyle="->", color='red'))

    plt.title("Supply and Demand Curves with Equilibrium")
    plt.xlabel("Price (P)")
    plt.ylabel("Quantity (Q)")
    plt.legend()
    plt.grid(True)
    plt.show()

print("Test case: Supply: Qs = -10 + 2*P, Demand: Qd = 100 - 3*P")
print("Expected equilibrium: P = 22, Q = 34")

# =============================================================================
# PUZZLE 2: ELASTICITY CALCULATOR
# =============================================================================

print("\n🧩 PUZZLE 2: Calculate Price Elasticity of Demand")
print("─" * 48)
print("Calculate price elasticity using the midpoint method")

# Sample price and quantity data
price_quantity_data = pd.DataFrame({
    'price': [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
    'quantity_demanded': [5, 8, 12, 17, 23, 30, 38, 47, 57, 68]
})

def calculate_elasticity(price1, quantity1, price2, quantity2):
    """
    Calculate price elasticity of demand using midpoint method.

    Elasticity = (% change in quantity) / (% change in price)
    Midpoint method: ((Q2 - Q1)/((Q2 + Q1)/2)) / ((P2 - P1)/((P2 + P1)/2))

    Returns classification string:
    - elastic if |elasticity| > 1
    - inelastic if |elasticity| < 1
    - unit elastic if |elasticity| == 1
    """
    # Avoid division by zero in denominator
    avg_qty = (quantity1 + quantity2) / 2
    avg_price = (price1 + price2) / 2

    if avg_qty == 0 or avg_price == 0:
        return {'elasticity': np.nan, 'classification': 'undefined'}

    pct_change_qty = (quantity2 - quantity1) / avg_qty
    pct_change_price = (price2 - price1) / avg_price

    if pct_change_price == 0:
        return {'elasticity': np.nan, 'classification': 'undefined'}

    elasticity = pct_change_qty / pct_change_price

    abs_elasticity = abs(elasticity)
    if abs_elasticity > 1:
        classification = "elastic"
    elif abs_elasticity < 1:
        classification = "inelastic"
    else:
        classification = "unit elastic"

    return {'elasticity': elasticity, 'classification': classification}

def analyze_demand_curve(df):
    """
    Analyze demand curve for elasticity between consecutive points.
    Returns a summary DataFrame with elasticity and classifications.
    Also plots demand curve colored by elasticity region.
    """
    results = []
    for i in range(len(df) - 1):
        p1, q1 = df.loc[i, 'price'], df.loc[i, 'quantity_demanded']
        p2, q2 = df.loc[i+1, 'price'], df.loc[i+1, 'quantity_demanded']
        res = calculate_elasticity(p1, q1, p2, q2)
        results.append({
            'price_range': f"{p1} -> {p2}",
            'elasticity': res['elasticity'],
            'classification': res['classification']
        })

    summary_df = pd.DataFrame(results)

    # Plot demand curve
    plt.figure(figsize=(8,6))
    colors = {'elastic':'red', 'inelastic':'blue', 'unit elastic':'green', 'undefined':'gray'}

    # Plot points
    for i in range(len(df)-1):
        x_vals = [df.loc[i, 'price'], df.loc[i+1, 'price']]
        y_vals = [df.loc[i, 'quantity_demanded'], df.loc[i+1, 'quantity_demanded']]
        cls = summary_df.loc[i, 'classification']
        plt.plot(x_vals, y_vals, color=colors.get(cls, 'black'), linewidth=3, label=f'{cls}' if i == 0 else "")

    plt.gca().invert_xaxis()  # Price axis decreasing (normal for demand)
    plt.xlabel("Price")
    plt.ylabel("Quantity Demanded")
    plt.title("Demand Curve with Elasticity Regions")
    plt.legend(['Elastic (|E|>1)', 'Inelastic (|E|<1)', 'Unit Elastic (|E|=1)'])
    plt.grid(True)
    plt.show()

    return summary_df

print("Test with the provided price_quantity_data")
print("Expected: Elasticity should vary along the demand curve")

# =============================================================================
# PUZZLE 3: CONSUMER AND PRODUCER SURPLUS
# =============================================================================

print("\n🧩 PUZZLE 3: Calculate Economic Surplus")
print("─" * 38)
print("Calculate consumer surplus, producer surplus, and deadweight loss")

def calculate_surplus(demand_intercept, demand_slope, supply_intercept, supply_slope,
                     price=None, quantity=None):
    """
    Calculate consumer and producer surplus for linear demand and supply.
    If price/quantity not given, calculate equilibrium first.

    Consumer surplus = area between demand curve and price line
    Producer surplus = area between supply curve and price line

    Formula for surplus with linear curves:
    Consumer Surplus = 0.5 * (Q) * (Price intercept on demand curve - Price)
    Producer Surplus = 0.5 * (Q) * (Price - Price intercept on supply curve)
    """
    # Find equilibrium if not provided
    if price is None or quantity is None:
        eq = find_equilibrium(supply_intercept, supply_slope, demand_intercept, demand_slope)
        if eq is None:
            raise ValueError("No equilibrium found for supply and demand curves.")
        price = eq['price']
        quantity = eq['quantity']

    # Price intercept on demand curve (where quantity = 0)
    # Qd = demand_intercept + demand_slope * P => 0 = demand_intercept + demand_slope * P
    price_demand_intercept = -demand_intercept / demand_slope if demand_slope != 0 else np.nan

    # Price intercept on supply curve (where quantity = 0)
    price_supply_intercept = -supply_intercept / supply_slope if supply_slope != 0 else np.nan

    consumer_surplus = 0.5 * quantity * (price_demand_intercept - price)
    producer_surplus = 0.5 * quantity * (price - price_supply_intercept)
    total_surplus = consumer_surplus + producer_surplus

    return {
        'consumer_surplus': consumer_surplus,
        'producer_surplus': producer_surplus,
        'total_surplus': total_surplus,
        'price': price,
        'quantity': quantity
    }

def deadweight_loss_analysis(demand_intercept, demand_slope, supply_intercept, supply_slope,
                           regulated_price):
    """
    Analyze deadweight loss when a price ceiling or floor is imposed.
    Calculate new surplus, deadweight loss, shortage/surplus.
    """
    eq = find_equilibrium(supply_intercept, supply_slope, demand_intercept, demand_slope)
    if eq is None:
        raise ValueError("No equilibrium to compare for deadweight loss.")

    eq_price = eq['price']
    eq_quantity = eq['quantity']

    # Calculate quantity demanded and supplied at regulated price
    qd = demand_intercept + demand_slope * regulated_price
    qs = supply_intercept + supply_slope * regulated_price

    # Determine if ceiling or floor
    regulation_type = "none"
    if regulated_price < eq_price:
        regulation_type = "price ceiling"
    elif regulated_price > eq_price:
        regulation_type = "price floor"

    # Calculate surplus at regulated price (quantity traded limited by min(qd, qs))
    traded_quantity = min(qd, qs)

    surplus_regulated = calculate_surplus(demand_intercept, demand_slope, supply_intercept, supply_slope,
                                          price=regulated_price, quantity=traded_quantity)

    surplus_eq = calculate_surplus(demand_intercept, demand_slope, supply_intercept, supply_slope,
                                   price=eq_price, quantity=eq_quantity)

    deadweight_loss = surplus_eq['total_surplus'] - surplus_regulated['total_surplus']

    # Shortage or surplus in quantity
    quantity_diff = qd - qs  # positive if shortage (qd > qs), negative if surplus

    return {
        'equilibrium_price': eq_price,
        'equilibrium_quantity': eq_quantity,
        'regulated_price': regulated_price,
        'quantity_demanded': qd,
        'quantity_supplied': qs,
        'traded_quantity': traded_quantity,
        'regulation_type': regulation_type,
        'consumer_surplus': surplus_regulated['consumer_surplus'],
        'producer_surplus': surplus_regulated['producer_surplus'],
        'total_surplus': surplus_regulated['total_surplus'],
        'deadweight_loss': deadweight_loss,
        'quantity_shortage_or_surplus': quantity_diff
    }

print("Test case: Same supply/demand from Puzzle 1")
print("Try regulated price of 15 (price ceiling)")

# =============================================================================
# PUZZLE 4: BUDGET CONSTRAINT AND UTILITY MAXIMIZATION
# =============================================================================

print("\n🧩 PUZZLE 4: Consumer Choice Theory")
print("─" * 37)
print("Find optimal consumption bundle given budget constraint and preferences")

def budget_constraint(income, price_x, price_y, num_points=100):
    """
    Generate budget constraint line points.
    Returns feasible (x,y) combinations along budget line.
    """
    max_x = income / price_x
    x_vals = np.linspace(0, max_x, num_points)
    y_vals = (income - price_x * x_vals) / price_y
    y_vals = np.maximum(y_vals, 0)  # Ensure non-negative consumption

    max_y = income / price_y

    return {'x_values': x_vals, 'y_values': y_vals, 'max_x': max_x, 'max_y': max_y}

def cobb_douglas_utility(x, y, alpha=0.5):
    """
    Calculate Cobb-Douglas utility U = x^alpha * y^(1-alpha).
    Supports arrays. Zero consumption returns 0 utility.
    """
    x = np.array(x)
    y = np.array(y)

    # Replace zeros with small positive number to avoid 0^something issues
    # But logically utility is zero if any good consumed is zero
    utility = np.where((x > 0) & (y > 0), x**alpha * y**(1-alpha), 0)
    return utility

def find_optimal_consumption(income, price_x, price_y, alpha=0.5):
    """
    Calculate utility-maximizing consumption bundle analytically:
    x* = (alpha * income) / price_x
    y* = ((1 - alpha) * income) / price_y
    """
    x_optimal = (alpha * income) / price_x
    y_optimal = ((1 - alpha) * income) / price_y

    # Verify budget constraint
    budget_used = price_x * x_optimal + price_y * y_optimal
    if not np.isclose(budget_used, income):
        raise ValueError("Budget constraint not satisfied")

    max_utility = cobb_douglas_utility(x_optimal, y_optimal, alpha)

    # Plot budget line and indifference curve
    bc = budget_constraint(income, price_x, price_y)

    plt.figure(figsize=(8,6))
    plt.plot(bc['x_values'], bc['y_values'], label='Budget Constraint', color='blue')

    # Plot indifference curve through optimal point: U = U*
    # For Cobb-Douglas: y = (U / x^alpha)^(1/(1-alpha))
    x_range = np.linspace(0.01, bc['max_x'], 200)
    y_indiff = (max_utility / (x_range ** alpha)) ** (1/(1 - alpha))

    plt.plot(x_range, y_indiff, label='Indifference Curve', color='orange')
    plt.scatter(x_optimal, y_optimal, color='red', s=80, label='Optimal Bundle')

    plt.xlim(0, bc['max_x']*1.1)
    plt.ylim(0, bc['max_y']*1.1)
    plt.xlabel("Quantity of Good X")
    plt.ylabel("Quantity of Good Y")
    plt.title("Budget Constraint and Indifference Curve")
    plt.legend()
    plt.grid(True)
    plt.show()

    return {'x_optimal': x_optimal, 'y_optimal': y_optimal, 'max_utility': max_utility}

print("Test case: Income = 100, Price_x = 5, Price_y = 2, alpha = 0.6")
print("Expected: x* = 12, y* = 20, U* ≈ 16.87")

# =============================================================================
# PUZZLE 5: GDP CALCULATION AND GROWTH RATES
# =============================================================================

print("\n🧩 PUZZLE 5: GDP Analysis")
print("─" * 25)
print("Calculate GDP using different methods and analyze growth rates")

economic_data = {
    'consumption': [800, 820, 850, 880, 900],
    'investment': [200, 180, 220, 240, 260],
    'government_spending': [300, 310, 305, 320, 330],
    'exports': [150, 160, 170, 180, 185],
    'imports': [120, 130, 145, 150, 155],
    'year': [2019, 2020, 2021, 2022, 2023]
}

gdp_data = pd.DataFrame(economic_data)

def calculate_gdp_expenditure(consumption, investment, government, exports, imports):
    """
    GDP = C + I + G + (X - M)
    Accept scalars or arrays (lists, np.arrays, pd.Series).
    """
    consumption = np.array(consumption)
    investment = np.array(investment)
    government = np.array(government)
    exports = np.array(exports)
    imports = np.array(imports)

    net_exports = exports - imports
    gdp = consumption + investment + government + net_exports
    return gdp

def calculate_growth_rates(gdp_series):
    """
    Calculate YoY GDP growth rates in percent.
    Also find average growth and recession years (negative growth).
    """
    gdp_series = pd.Series(gdp_series)
    growth_rates = gdp_series.pct_change() * 100  # percent

    average_growth = growth_rates[1:].mean()  # exclude NaN for first year
    recession_years = gdp_series.index[growth_rates < 0].tolist()

    return {
        'growth_rates': growth_rates,
        'average_growth': average_growth,
        'recession_years': recession_years
    }

def gdp_analysis_dashboard(df):
    """
    Compute GDP and growth rates, plot and summarize key info.
    """
    df = df.copy()
    df['GDP'] = calculate_gdp_expenditure(
        df['consumption'], df['investment'], df['government_spending'],
        df['exports'], df['imports']
    )

    growth_info = calculate_growth_rates(df['GDP'])
    df['GDP_growth'] = growth_info['growth_rates']

    # Plot GDP and growth rates
    fig, ax1 = plt.subplots(figsize=(10,6))

    ax1.plot(df['year'], df['GDP'], 'b-o')
    ax1.set_xlabel('Year')
    ax1.set_ylabel('GDP', color='b')
    ax1.tick_params(axis='y', labelcolor='b')
    ax1.set_title('GDP and Growth Rate Over Time')

    ax2 = ax1.twinx()
    ax2.plot(df['year'], df['GDP_growth'], 'r--o')
    ax2.set_ylabel('GDP Growth Rate (%)', color='r')
    ax2.tick_params(axis='y', labelcolor='r')

    plt.show()

    # Plot components stacked bar
    plt.figure(figsize=(10,6))
    components = ['consumption', 'investment', 'government_spending', 'exports', 'imports']
    df.set_index('year')[components].plot(kind='bar', stacked=False)
    plt.title('Economic Components Over Years')
    plt.ylabel('Value')
    plt.show()

    summary = {
        'average_growth_rate': growth_info['average_growth'],
        'recession_years': growth_info['recession_years'],
        'max_gdp': df['GDP'].max(),
        'min_gdp': df['GDP'].min(),
        'years': df['year'].tolist()
    }

    return {'data': df, 'summary': summary}

print("Test with provided economic_data")
print("Expected: GDP should show overall upward trend with growth rate variations")

# =============================================================================
# PUZZLE 6: INFLATION AND REAL VS NOMINAL VALUES
# =============================================================================

print("\n🧩 PUZZLE 6: Price Index and Inflation Analysis")
print("─" * 47)
print("Calculate CPI, inflation rates, and convert nominal to real values")

price_data = pd.DataFrame({
    'year': [2020, 2021, 2022, 2023],
    'bread_price': [2.50, 2.65, 2.80, 3.00],
    'milk_price': [3.20, 3.35, 3.60, 3.75],
    'gas_price': [2.85, 3.10, 4.20, 3.80],
    'bread_quantity': [100, 100, 100, 100],  # Base year quantities
    'milk_quantity': [50, 50, 50, 50],
    'gas_quantity': [200, 200, 200, 200]
})

def calculate_cpi(df, base_year=2020):
    """
    Calculate CPI using Laspeyres method.
    CPI_t = (Cost of basket in year t / Cost in base year) * 100
    Base year CPI = 100
    """
    base_year_row = df[df['year'] == base_year].iloc[0]
    base_cost = (base_year_row['bread_price'] * base_year_row['bread_quantity'] +
                 base_year_row['milk_price'] * base_year_row['milk_quantity'] +
                 base_year_row['gas_price'] * base_year_row['gas_quantity'])

    cpi_values = []
    for _, row in df.iterrows():
        cost = (row['bread_price'] * base_year_row['bread_quantity'] +
                row['milk_price'] * base_year_row['milk_quantity'] +
                row['gas_price'] * base_year_row['gas_quantity'])
        cpi = (cost / base_cost) * 100
        cpi_values.append(cpi)

    return pd.Series(cpi_values, index=df['year'])

def calculate_inflation_rate(cpi_series):
    """
    Calculate annual inflation rate from CPI series.
    Inflation rate = ((CPI_t - CPI_t-1)/CPI_t-1)*100
    """
    inflation_rates = cpi_series.pct_change() * 100
    average_inflation = inflation_rates[1:].mean()  # Exclude first NaN
    return {'inflation_rates': inflation_rates, 'average_inflation': average_inflation}

def nominal_to_real(nominal_values, cpi_values, base_year_cpi=100):
    """
    Convert nominal values to real values using CPI deflator.
    Real = Nominal / CPI * base_year_CPI
    """
    nominal_values = np.array(nominal_values)
    cpi_values = np.array(cpi_values)
    real_values = nominal_values / cpi_values * base_year_cpi
    return real_values

print("Test with provided price_data")
print("Expected: CPI should generally increase, showing inflation")

# =============================================================================
# TESTING SECTION
# =============================================================================

print("\n" + "=" * 60)
print("TESTING YOUR SOLUTIONS")
print("=" * 60)
print("Run your functions with the test cases provided above.")
print("Make sure to:")
print("1. Handle edge cases appropriately")
# 2. Include proper error checking") # Fixed: Commented out the line
print("3. Add clear documentation")
print("4. Create meaningful visualizations")
print("5. Test with different parameter values")
print("\nGood luck! 🚀")

def run_tests():
    """
    Run basic tests for all puzzle solutions.
    """
    print("\n🧪 Running basic tests...")
    # Puzzle 1
    eq = find_equilibrium(-10, 2, 100, -3)
    print(f"Puzzle 1 Equilibrium: {eq}")
    if eq:
        plot_supply_demand(-10, 2, 100, -3, eq)

    # Puzzle 2
    elast = calculate_elasticity(10, 5, 9, 8)
    print(f"Puzzle 2 Elasticity (10->9 price): {elast}")
    summary = analyze_demand_curve(price_quantity_data)
    print(summary)

    # Puzzle 3
    surplus = calculate_surplus(100, -3, -10, 2)
    print(f"Puzzle 3 Surplus at equilibrium: {surplus}")
    dloss = deadweight_loss_analysis(100, -3, -10, 2, regulated_price=15)
    print(f"Puzzle 3 Deadweight Loss Analysis (price ceiling 15): {dloss}")

    # Puzzle 4
    opt = find_optimal_consumption(100, 5, 2, alpha=0.6)
    print(f"Puzzle 4 Optimal consumption: {opt}")

    # Puzzle 5
    gdp = calculate_gdp_expenditure(
        gdp_data['consumption'], gdp_data['investment'], gdp_data['government_spending'],
        gdp_data['exports'], gdp_data['imports']
    )
    print(f"Puzzle 5 GDP values: {gdp}")
    growth_info = calculate_growth_rates(gdp)
    print(f"Puzzle 5 Growth rates: {growth_info['growth_rates'].values}")
    dash = gdp_analysis_dashboard(gdp_data)
    print(f"Puzzle 5 Summary: {dash['summary']}")

    # Puzzle 6
    cpi_series = calculate_cpi(price_data, base_year=2020)
    print(f"Puzzle 6 CPI: \n{cpi_series}")
    inflation_info = calculate_inflation_rate(cpi_series)
    print(f"Puzzle 6 Inflation rates:\n{inflation_info['inflation_rates']}")
    # Nominal to real example: assume nominal incomes for years
    nominal_incomes = [50000, 52000, 55000, 58000]
    real_incomes = nominal_to_real(nominal_incomes, cpi_series)
    print(f"Puzzle 6 Real incomes (base 2020): {real_incomes}")

if __name__ == "__main__":
    run_tests()